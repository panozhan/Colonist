<!DOCTYPE html>
<html>
    <head>
    <title>Colonist</title>
    <style>
        body { margin: 0; padding: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #games-container {display: none; flex-wrap: wrap; justify-content: space-evenly;}
        .game-room {width: 250px; height: 350px; border-radius: 1rem; box-shadow: 0 0 20px grey; transition: width 0.1s, height 0.13s, box-shadow 0.1s linear; display: flex; flex-direction: column; justify-content: center; text-align: center; font-size:x-large}
        .game-room:hover {width: 260px; height: 360px; border-radius: 1rem; box-shadow: 0 0 20px black; cursor: pointer}
        #new-game { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; box-sizing: border-box; backdrop-filter: blur(10px); cursor: default;}
        #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; font-size:large;}
        #new-game > button {flex-grow: 1; cursor: pointer;}
        #game-canvas {display: block; margin:0; padding: 0;}
    </style>
    </head>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module">
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r127/build/three.module.js';
        function changeGames(games) {
            const container = document.getElementById('games-container');
            games.forEach(game => {
                const ele = document.createElement('div');
                ele.classList.add('game-room');
                ele.innerText = `Join Existing Game: "${game}"`
                container.appendChild(ele);
            });
        }

        function runGame(canvas) {
            // canvas.addEventListener('click', (e) => {
            //     console.log(e);
            // });
            // const renderer = new THREE.WebGLRenderer({canvas});
            // renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
            // // TODO: set these values dynamically
            // const fov = 75;
            // const aspect = canvas.clientWidth / canvas.clientHeight;  // the canvas default
            // const near = 0.1;
            // const far = 10;
            // const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            // camera.position.z = 5;
            // const scene = new THREE.Scene();

            // const geometry = new THREE.CylinderGeometry(1, 1, 0.1, 6);
            // const loader = new THREE.TextureLoader();
            // const materials = [
            //     new THREE.MeshBasicMaterial({map: loader.load('./static/bricks.png')}),
            //     new THREE.MeshBasicMaterial({map: loader.load('./static/bricks.png')}),
            //     new THREE.MeshBasicMaterial({map: loader.load('./static/bricks.png')}),
            // ];
            // const hexagon = new THREE.Mesh(geometry, materials);
            // hexagon.rotation.x = 1.5708
            // scene.add(hexagon);
            // const light = new THREE.DirectionalLight(0xFFFFFF, 1);
            // light.position.set(-1, 2, 4);
            // scene.add(light);

            // renderer.render(scene, camera);
            // function render(time) {
            //     time *= 0.001;  // convert time to seconds
                
            //     cube.rotation.x = time;
            //     cube.rotation.y = time;
                
            //     renderer.render(scene, camera);
                
            //     requestAnimationFrame(render);
            // }
            // requestAnimationFrame(render);

            const renderer = new THREE.WebGLRenderer({canvas});

            const fov = 75;
            const aspect = 2;  // the canvas default
            const near = 0.1;
            const far = 5;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 2;

            const scene = new THREE.Scene();

            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.CylinderGeometry(1, 1, 0.01, 6);

            const cubes = [];  // just an array we can use to rotate the cubes
            const loader = new THREE.TextureLoader();

            const brickMaterial = new THREE.MeshBasicMaterial({
                map: loader.load('./static/bricks.png'),
            });
            const cube = new THREE.Mesh(geometry, brickMaterial);
            scene.add(cube);
            cubes.push(cube);  // add to our list of cubes to rotate

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                renderer.setSize(width, height, false);
                }
                return needResize;
            }

            function render(time) {
                time *= 0.001;

                if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                }

                cubes.forEach((cube, ndx) => {
                const speed = .2 + ndx * .1;
                const rot = time * speed;
                cube.rotation.x = rot;
                cube.rotation.y = rot;
                });

                renderer.render(scene, camera);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }
        const socket = io();
        const games = ['Alex test game - with a very freaking long name lol xyz'];
        let windowLoaded = false;

        socket.on('all-games', (msg) => {
            const parsed = JSON.parse(msg);
            parsed.forEach(game => {
                games.push(game);
            });
            if (windowLoaded) {
                changeGames(games);
            }
        });
        window.onload = event => {
            // socket.emit('chat message', input.value);
            windowLoaded = true;
            if (games.length > 0) {
                changeGames(games);
            }
            document.getElementById('new-game').addEventListener('submit', (e) => {
                e.preventDefault();
                if (input.value) {
                    socket.emit('new game', input.value, (res) => {
                        if (res.success === 1) {
                            const canvas = document.getElementById('game-canvas');
                            canvas.style.display = 'block';
                            canvas.style.width = '100vw';
                            canvas.style.height = '100vh';
                            document.getElementById('games-container').style.display = 'none';
                            document.getElementsByTagName('body')[0].style.padding = '0px';
                            runGame(canvas);
                        } else {
                            document.getElementById('new-game-instruction')
                                .innerText = 'Sorry the game name is already taken. Please choose another name.'
                        }
                        console.log(res);
                    });
                }
            });
            document.getElementsByTagName('body')[0].style.padding = '0px';
            const canvas = document.getElementById('game-canvas');
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
            runGame(canvas);
        }
    </script>
    <body>
        <div id="games-container">
            <form id="new-game" class="game-room" action=""> 
                <span id="new-game-instruction">Enter the name of your game:</span>
                <input id="input" autocomplete="off" />
                <button>Create New Game</button>
            </form>
        </div>
        <canvas id="game-canvas"></canvas>
    </body>
</html>